Microsoft (R) Macro Assembler Version 6.11		    12/07/25 12:31:28
HEAPSORT.asm						     Page 1 - 1


				; TODO Work in-progress, needs testing and some checks/debugging
				.8086
				.model small, C

				get_left MACRO dest:REQ, i:REQ
					mov al, i
					shl al, 1 		; i*2
					mov dest, al 	;; L or R are set a val here
				ENDM

				get_right MACRO dest:REQ, i:REQ
					mov al, i 
					shl al, 1 	
					inc ax			; i*2+1
					mov dest, al
				ENDM

 000B				HEAP STRUCT 

 0000  00				heapsize  BYTE ?
 0001  000A [				A         BYTE 10 DUP(?)
        00
       ]

				HEAP ENDS


				.stack 100h
 0000				.data
						
					PHEAP   TYPEDEF PTR HEAP					; TYPEDEFs may need to be outside any seg
 0000 45 6E 74 65 72 20			prompt  db "Enter array to sort:", "$"
       61 72 72 61 79 20
       74 6F 20 73 6F 72
       74 3A 24
 0015 53 6F 72 74 65 64			result  db "Sorted array:", "$"
       20 61 72 72 61 79
       3A 24
 0023 0D 0A 0D 0A 24			crlf    db 0Dh, 0Ah, 0Dh, 0Ah, "$" 			; newline
 0028 13 00				input   db 19, 0, 19 DUP(?) 				; DOS input str
       0013 [
        00
       ]
 003D 00				arrsize db ?
 003E 00				array   HEAP <>
       000A [
        00
       ]
 0049  000A [				testme db 10 DUP(0)
        00
       ]
					
 0000				.code
				INCLUDE DOSPARSE.INC
			      C PBYTE TYPEDEF PTR BYTE	; PTR to byte (arr of chars or integers)
			      C input_to_arr PROTO NEAR C pinput:PBYTE, parr:PBYTE
			      C print_arr PROTO NEAR C asize:BYTE, parr:PBYTE
			      C 
			      C ; Synopsis
			      C ;	write a str to stdout via DOS
			      C writestr MACRO string:REQ
			      C 	
			      C 	; this example does not push/pop ax,dx to preserve regs
			      C 	mov ah, 9
			      C 	mov dx, offset string
			      C 	int 21h
			      C 	
			      C ENDM
			      C 
			      C ; Synopsis:
			      C ;	Parse DOS input buffer into byte array 
			      C ; Parameters:
			      C ;	pinput: pointer to DOS input buffer
			      C ;	parr  : pointer to dest byte arr
			      C ; Returns:
			      C ;	arrsize >> ax
			      C ; Learning:
			      C ;	(1) MASM has implied dereferencing for all data labels, 
			      C ;	    incl. LOCAL variables as shown in this proc
			      C ;   (2) When using ptr args, MASM does not expl. retrive values.
			      C ;		You must use two MOV instructions, one to retrieve the value
			      C ;		and the other to dereference. For instance, not doing line 20
			      C ;		but proceeding to do mov ax, [pinput+1] is double indirection, 
			      C ;	    (which is illegal), since any stack param in the proc resolves to
			      C ;		[bp-<offset>]. This is why something like mov myStackWord, 0 is OK,
			      C ;		bc it resolves to mov [bp-2], 0
 0000			      C input_to_arr PROC C USES bx cx dx si di, pinput:PBYTE, parr:PBYTE
			      C 
			      C 	LOCAL asize:BYTE		; asize = arrsize to prevent symbol conflict
 000B  C6 46 FF 00	      C 	mov asize, 0			; initialize local var
 000F  8B 76 04		      C 	mov si, pinput          ; first load the address of input
 0012  8B 7E 06		      C 	mov di, parr			; first load the address of arr
			      C 	
 0015  B9 0002		      C 	mov cx, 2				; prep index (cx = i = 2)
 0018  33 D2		      C 	xor dx, dx				; dx = j = 0 (prep index)
 001A  EB 00		      C 	jmp itr_loop
 001C			      C itr_loop:
 001C  8A 44 01		      C 	mov al, [si + 1]        ; al holds DOS chars read (incl. commas)
 001F  40		      C 	inc ax 					; +1 to account for input indexing
 0020  8A D8		      C 	mov bl, al				; save this index upper bound for now
 0022  D0 E8		      C 	shr al, 1				; divide by two (faster than using div)
 0024  88 46 FF		      C 	mov [asize], al		    ; arrsize now holds # of ints in arr
 0027  8A C3		      C 	mov al, bl				; restore al to DOS input indexing 
			      C 	
 0029  38 C1		      C 	cmp cl, al 	
 002B  7E 0C		      C 	jle parse_value				 ; if i < len(input_arr), xchg value 
 002D  8A 46 FF		      C 	mov al, [asize]			 ; Load arrsize into AL for return
			      C 	RET							 ; array parsed
 0039			      C parse_value:
 0039  8A D9		      C 	mov bl, cl					 ; load i for indexing
 003B  32 E4		      C 	xor ah, ah
 003D  8A 00		      C 	mov al, [si + bx]			 ; ax = input[i]
 003F  2C 30		      C 	sub al, '0'					 ; convert ASCII to number (0x35 -> 0x05)
 0041  8A DA		      C 	mov bl, dl					 ; load j for indexing
 0043  88 01		      C 	mov BYTE PTR [di + bx], al   ; arr[j] = arr[i]
 0045  83 C1 02		      C 	add cx, 2					 ; 2, 4, 6, 8, ...
 0048  42		      C 	inc dx						 ; 0, 1, 2, 3, ...
 0049  EB D1		      C 	jmp itr_loop
			      C 
 004B			      C input_to_arr endp
			      C 
			      C ; Synopsis:
			      C ; 	Print an integer array in the form <i>, <i+1>, ... <n>
			      C ;	where i is an index and n is the last index of the array
			      C ; Parameters:
			      C ; 	asize: byte representing size of array (255 max)
			      C ; 	parr : pointer to integer array to be printed  
			      C ; Returns:
			      C ; 	N/A
 004B			      C print_arr PROC C USES ax cx dx si, asize:BYTE, parr:PBYTE
			      C 	LOCAL i:BYTE			; elem index
 0055  C6 46 FF 00	      C 	mov i, 0
 0059  8B 76 06		      C 	mov si, parr			; holds start of arr (address)
 005C  33 C9		      C 	xor cx, cx				; ensure its clear
 005E  8A 4E 04		      C 	mov cl, [asize]		    ; cx holds size of array
 0061			      C print_loop:
 0061  8A 14		      C 	mov dl, [si]
 0063  80 C2 30		      C 	add dl, '0'
 0066  B4 02		      C 	mov ah, 02h				; DOS print char
 0068  CD 21		      C 	int 21h
			      C 
 006A  B2 20		      C 	mov dl, ' '				; print space
 006C  B4 02		      C 	mov ah, 02h
 006E  CD 21		      C 	int 21h
			      C 
 0070  46		      C 	inc si					; next elem address 
 0071  FE 46 FF		      C 	inc i					; next elem index
 0074  38 4E FF		      C 	cmp [i], cl
 0077  7C E8		      C 	jl print_loop
			      C 	RET
			      C 
 0081			      C print_arr endp
			      C 
				heapsort       PROTO C p_heap: PHEAP
				max_heapify    PROTO C p_heap: PHEAP, i: BYTE
				build_max_heap PROTO C p_heacdp: PHEAP
				.STARTUP
 0098				main proc

					writestr prompt
 0098  B4 09		     1		mov ah, 9
 009A  BA 0000 R	     1		mov dx, offset prompt
 009D  CD 21		     1		int 21h
 009F  BA 0028 R			mov dx, offset input 
 00A2  B4 0A				mov ah, 0Ah
 00A4  CD 21				int 21h
					
					INVOKE input_to_arr, offset input, offset array.A
 00B4  A2 003D R			mov arrsize, al
					INVOKE heapsort, ADDR array
					
					writestr crlf
 00C2  B4 09		     1		mov ah, 9
 00C4  BA 0023 R	     1		mov dx, offset crlf
 00C7  CD 21		     1		int 21h
					INVOKE print_arr, arrsize, offset array.A		
					
				.EXIT
 00DB				main endp

 00DB				heapsort proc USES ax bx cx, p_heap: PHEAP 
					
 00E1  8B 76 04				mov si, p_heap					; load base addr of HEAP_STRUCT
					
					INVOKE build_max_heap, p_heap
 00ED  8A 0E 003D R			mov cl, arrsize
					
 00F1				sort_array:
					
 00F1  8B D9				mov bx, cx
 00F3  8A 44 01				mov al, [si + 1] 					; A[1]
 00F6  86 00				xchg [si + bx], al					; A[i] = A[1], al = old A[i]
 00F8  88 44 01				mov [si + 1], al					; A[1] = A[i]
					
 00FB  8A 04				mov al, (HEAP PTR [si]).heapsize	; A[0] A.heapsize
 00FD  FE C8				dec al								; A.heapsize -= 1
 00FF  88 04				mov (HEAP PTR [si]).heapsize, al
					INVOKE max_heapify, p_heap, 1			
					
 010D  E2 E2				LOOP sort_array						; impl. dec cx, loop til CX=0
					
					RET
					
 0114				heapsort endp

 0114				max_heapify proc USES si, p_heap: PHEAP, i: BYTE
					
					LOCAL       L: BYTE
					LOCAL       R: BYTE
					LOCAL largest: BYTE
					
					; set L and R vars
					get_left L, i
 011B  8A 46 06		     1		mov al, i
 011E  D0 E0		     1		shl al, 1 		
 0120  88 46 FF		     1		mov L, al 	
					get_right R, i
 0123  8A 46 06		     1		mov al, i 
 0126  D0 E0		     1		shl al, 1 	
 0128  40		     1		inc ax			
 0129  88 46 FE		     1		mov R, al
					
 012C  8B 76 04				mov si, p_heap				; load entire struct
 012F  8A 46 FF				mov al, L
 0132  8A D8				mov bl, al			
 0134  8A 10				mov dl, [si + bx]			; A[L]
 0136  8A 5E 06				mov bl, i
					
					; MASM distinguishes auto between instruction 
					; and operator forms based on context
					.IF (al <= BYTE PTR [si]) && (dl > [si + bx])
 0141  88 46 FD					mov largest, al
					.ELSE
 0146  88 5E FD					mov largest, bl 		; largest = i
					.ENDIF
					
 0149  8A 46 FE				mov al, R
 014C  8B D8				mov bx, ax
 014E  8B 10				mov dx, [si + bx]			; A[R]
 0150  8A 5E FD				mov bl, largest
					.IF (al <= BYTE PTR [si]) && (dl > [si + bx])
 015B  88 46 FD					mov largest, al
					.ENDIF
					
 015E  8A 5E 06				mov bl, i
					.IF largest != bl
 0166  8A 5E FD					mov bl, largest			; cannot use LOCAL mem var as an index
 0169  8A 10					mov dl, [si + bx]		; A[largest]
 016B  8A 5E 06					mov bl, i				; A[i]
 016E  86 10					xchg [si + bx], dl		; A[i] = A[largest], dl = old A[i]
 0170  8A 5E FD					mov bl, largest
 0173  88 10					mov [si + bx], dl		; A[largest] = old A[i]
						
						INVOKE max_heapify, si, largest
					.ENDIF
					RET

 0185				max_heapify endp

 0185				build_max_heap proc USES cx, p_heap: PHEAP

 0189  8B 76 04				mov si, p_heap
 018C  A0 003D R			mov al, arrsize 	    			; do I really gotta do this?
 018F  88 04				mov (HEAP PTR [si]).heapsize, al	; A.heapsize = n
					
 0191  D1 E8				shr ax, 1			; div by 2
 0193  8B C8				mov cx, ax			; i = n/2
					
 0195				build:

					INVOKE max_heapify, p_heap, cl
 01A1  E2 F2				LOOP build
					
					RET
					
 01A6				build_max_heap endp

				END
Microsoft (R) Macro Assembler Version 6.11		    12/07/25 12:31:28
HEAPSORT.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

get_left . . . . . . . . . . . .	Proc
get_right  . . . . . . . . . . .	Proc
writestr . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

HEAP . . . . . . . . . . . . . .	 000B
  heapsize . . . . . . . . . . .	 0000	     Byte
  A  . . . . . . . . . . . . . .	 0001	     Byte


Types:

                N a m e                  Size     Attr

PBYTE  . . . . . . . . . . . . .	 0002	  PTR Byte 
PHEAP  . . . . . . . . . . . . .	 0002	  PTR HEAP 


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 0053	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0100	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 01A6	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

build_max_heap . . . . . . . . .	P Near	 0185	  _TEXT	Length= 0021 Public C
  p_heap . . . . . . . . . . . .	Word	 bp + 0004
  build  . . . . . . . . . . . .	L Near	 0195	  _TEXT	
heapsort . . . . . . . . . . . .	P Near	 00DB	  _TEXT	Length= 0039 Public C
  p_heap . . . . . . . . . . . .	Word	 bp + 0004
  sort_array . . . . . . . . . .	L Near	 00F1	  _TEXT	
input_to_arr . . . . . . . . . .	P Near	 0000	  _TEXT	Length= 004B Public C
  pinput . . . . . . . . . . . .	Word	 bp + 0004
  parr . . . . . . . . . . . . .	Word	 bp + 0006
  asize  . . . . . . . . . . . .	Byte	 bp - 0001
  itr_loop . . . . . . . . . . .	L Near	 001C	  _TEXT	
  parse_value  . . . . . . . . .	L Near	 0039	  _TEXT	
main . . . . . . . . . . . . . .	P Near	 0098	  _TEXT	Length= 0043 Public C
max_heapify  . . . . . . . . . .	P Near	 0114	  _TEXT	Length= 0071 Public C
  p_heap . . . . . . . . . . . .	Word	 bp + 0004
  i  . . . . . . . . . . . . . .	Byte	 bp + 0006
  L  . . . . . . . . . . . . . .	Byte	 bp - 0001
  R  . . . . . . . . . . . . . .	Byte	 bp - 0002
  largest  . . . . . . . . . . .	Byte	 bp - 0003
print_arr  . . . . . . . . . . .	P Near	 004B	  _TEXT	Length= 0036 Public C
  asize  . . . . . . . . . . . .	Byte	 bp + 0004
  parr . . . . . . . . . . . . .	Word	 bp + 0006
  i  . . . . . . . . . . . . . .	Byte	 bp - 0001
  print_loop . . . . . . . . . .	L Near	 0061	  _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0001h	 
@Model . . . . . . . . . . . . .	Number	 0002h	 
@Startup . . . . . . . . . . . .	L Near	 0081	  _TEXT	
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
array  . . . . . . . . . . . . .	HEAP	 003E	  _DATA	
arrsize  . . . . . . . . . . . .	Byte	 003D	  _DATA	
crlf . . . . . . . . . . . . . .	Byte	 0023	  _DATA	
input  . . . . . . . . . . . . .	Byte	 0028	  _DATA	
prompt . . . . . . . . . . . . .	Byte	 0000	  _DATA	
result . . . . . . . . . . . . .	Byte	 0015	  _DATA	
testme . . . . . . . . . . . . .	Byte	 0049	  _DATA	

	   0 Warnings
	   0 Errors
